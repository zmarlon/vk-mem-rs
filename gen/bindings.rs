/* automatically generated by rust-bindgen 0.59.2 */

use ash::vk::*;

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[doc = " \\brief Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you."]
#[doc = ""]
#[doc = "Using this flag may increase performance because internal mutexes are not used."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT:
    VmaAllocatorCreateFlagBits = 1;
#[doc = " \\brief Enables usage of VK_KHR_dedicated_allocation extension."]
#[doc = ""]
#[doc = "The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`."]
#[doc = "When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1."]
#[doc = ""]
#[doc = "Using this extension will automatically allocate dedicated blocks of memory for"]
#[doc = "some buffers and images instead of suballocating place for them out of bigger"]
#[doc = "memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT"]
#[doc = "flag) when it is recommended by the driver. It may improve performance on some"]
#[doc = "GPUs."]
#[doc = ""]
#[doc = "You may set this flag only if you found out that following device extensions are"]
#[doc = "supported, you enabled them while creating Vulkan device passed as"]
#[doc = "VmaAllocatorCreateInfo::device, and you want them to be used internally by this"]
#[doc = "library:"]
#[doc = ""]
#[doc = "- VK_KHR_get_memory_requirements2 (device extension)"]
#[doc = "- VK_KHR_dedicated_allocation (device extension)"]
#[doc = ""]
#[doc = "When this flag is set, you can experience following warnings reported by Vulkan"]
#[doc = "validation layer. You can ignore them."]
#[doc = ""]
#[doc = "> vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT:
    VmaAllocatorCreateFlagBits = 2;
#[doc = "Enables usage of VK_KHR_bind_memory2 extension."]
#[doc = ""]
#[doc = "The flag works only if VmaAllocatorCreateInfo::vulkanApiVersion `== VK_API_VERSION_1_0`."]
#[doc = "When it is `VK_API_VERSION_1_1`, the flag is ignored because the extension has been promoted to Vulkan 1.1."]
#[doc = ""]
#[doc = "You may set this flag only if you found out that this device extension is supported,"]
#[doc = "you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,"]
#[doc = "and you want it to be used internally by this library."]
#[doc = ""]
#[doc = "The extension provides functions `vkBindBufferMemory2KHR` and `vkBindImageMemory2KHR`,"]
#[doc = "which allow to pass a chain of `pNext` structures while binding."]
#[doc = "This flag is required if you use `pNext` parameter in vmaBindBufferMemory2() or vmaBindImageMemory2()."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT:
    VmaAllocatorCreateFlagBits = 4;
#[doc = "Enables usage of VK_EXT_memory_budget extension."]
#[doc = ""]
#[doc = "You may set this flag only if you found out that this device extension is supported,"]
#[doc = "you enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,"]
#[doc = "and you want it to be used internally by this library, along with another instance extension"]
#[doc = "VK_KHR_get_physical_device_properties2, which is required by it (or Vulkan 1.1, where this extension is promoted)."]
#[doc = ""]
#[doc = "The extension provides query for current memory usage and budget, which will probably"]
#[doc = "be more accurate than an estimation used by the library otherwise."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_EXT_MEMORY_BUDGET_BIT:
    VmaAllocatorCreateFlagBits = 8;
#[doc = "Enables usage of VK_AMD_device_coherent_memory extension."]
#[doc = ""]
#[doc = "You may set this flag only if you:"]
#[doc = ""]
#[doc = "- found out that this device extension is supported and enabled it while creating Vulkan device passed as VmaAllocatorCreateInfo::device,"]
#[doc = "- checked that `VkPhysicalDeviceCoherentMemoryFeaturesAMD::deviceCoherentMemory` is true and set it while creating the Vulkan device,"]
#[doc = "- want it to be used internally by this library."]
#[doc = ""]
#[doc = "The extension and accompanying device feature provide access to memory types with"]
#[doc = "`VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD` and `VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD` flags."]
#[doc = "They are useful mostly for writing breadcrumb markers - a common method for debugging GPU crash/hang/TDR."]
#[doc = ""]
#[doc = "When the extension is not enabled, such memory types are still enumerated, but their usage is illegal."]
#[doc = "To protect from this error, if you don't create the allocator with this flag, it will refuse to allocate any memory or create a custom pool in such memory type,"]
#[doc = "returning `VK_ERROR_FEATURE_NOT_PRESENT`."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_AMD_DEVICE_COHERENT_MEMORY_BIT:
    VmaAllocatorCreateFlagBits = 16;
#[doc = "Enables usage of \"buffer device address\" feature, which allows you to use function"]
#[doc = "`vkGetBufferDeviceAddress*` to get raw GPU pointer to a buffer and pass it for usage inside a shader."]
#[doc = ""]
#[doc = "You may set this flag only if you:"]
#[doc = ""]
#[doc = "1. (For Vulkan version < 1.2) Found as available and enabled device extension"]
#[doc = "VK_KHR_buffer_device_address."]
#[doc = "This extension is promoted to core Vulkan 1.2."]
#[doc = "2. Found as available and enabled device feature `VkPhysicalDeviceBufferDeviceAddressFeatures::bufferDeviceAddress`."]
#[doc = ""]
#[doc = "When this flag is set, you can create buffers with `VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT` using VMA."]
#[doc = "The library automatically adds `VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT` to"]
#[doc = "allocated memory blocks wherever it might be needed."]
#[doc = ""]
#[doc = "For more information, see documentation chapter \\ref enabling_buffer_device_address."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_BUFFER_DEVICE_ADDRESS_BIT:
    VmaAllocatorCreateFlagBits = 32;
#[doc = "Enables usage of VK_EXT_memory_priority extension in the library."]
#[doc = ""]
#[doc = "You may set this flag only if you found available and enabled this device extension,"]
#[doc = "along with `VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE`,"]
#[doc = "while creating Vulkan device passed as VmaAllocatorCreateInfo::device."]
#[doc = ""]
#[doc = "When this flag is used, VmaAllocationCreateInfo::priority and VmaPoolCreateInfo::priority"]
#[doc = "are used to set priorities of allocated Vulkan memory. Without it, these variables are ignored."]
#[doc = ""]
#[doc = "A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations."]
#[doc = "Larger values are higher priority. The granularity of the priorities is implementation-dependent."]
#[doc = "It is automatically passed to every call to `vkAllocateMemory` done by the library using structure `VkMemoryPriorityAllocateInfoEXT`."]
#[doc = "The value to be used for default priority is 0.5."]
#[doc = "For more details, see the documentation of the VK_EXT_memory_priority extension."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT:
    VmaAllocatorCreateFlagBits = 64;
#[doc = "Enables usage of VK_EXT_memory_priority extension in the library."]
#[doc = ""]
#[doc = "You may set this flag only if you found available and enabled this device extension,"]
#[doc = "along with `VkPhysicalDeviceMemoryPriorityFeaturesEXT::memoryPriority == VK_TRUE`,"]
#[doc = "while creating Vulkan device passed as VmaAllocatorCreateInfo::device."]
#[doc = ""]
#[doc = "When this flag is used, VmaAllocationCreateInfo::priority and VmaPoolCreateInfo::priority"]
#[doc = "are used to set priorities of allocated Vulkan memory. Without it, these variables are ignored."]
#[doc = ""]
#[doc = "A priority must be a floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations."]
#[doc = "Larger values are higher priority. The granularity of the priorities is implementation-dependent."]
#[doc = "It is automatically passed to every call to `vkAllocateMemory` done by the library using structure `VkMemoryPriorityAllocateInfoEXT`."]
#[doc = "The value to be used for default priority is 0.5."]
#[doc = "For more details, see the documentation of the VK_EXT_memory_priority extension."]
pub const VmaAllocatorCreateFlagBits_VMA_ALLOCATOR_CREATE_FLAG_BITS_MAX_ENUM:
    VmaAllocatorCreateFlagBits = 2147483647;
#[doc = " Flags for created #VmaAllocator."]
pub type VmaAllocatorCreateFlagBits = ::std::os::raw::c_uint;
pub type VmaAllocatorCreateFlags = Flags;
#[doc = " No intended memory usage specified."]
#[doc = "Use other members of VmaAllocationCreateInfo to specify your requirements."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_UNKNOWN: VmaMemoryUsage = 0;
#[doc = " Memory will be used on device only, so fast access from the device is preferred."]
#[doc = "It usually means device-local GPU (video) memory."]
#[doc = "No need to be mappable on host."]
#[doc = "It is roughly equivalent of `D3D12_HEAP_TYPE_DEFAULT`."]
#[doc = ""]
#[doc = "Usage:"]
#[doc = ""]
#[doc = "- Resources written and read by device, e.g. images used as attachments."]
#[doc = "- Resources transferred from host once (immutable) or infrequently and read by"]
#[doc = "device multiple times, e.g. textures to be sampled, vertex buffers, uniform"]
#[doc = "(constant) buffers, and majority of other types of resources used on GPU."]
#[doc = ""]
#[doc = "Allocation may still end up in `HOST_VISIBLE` memory on some implementations."]
#[doc = "In such case, you are free to map it."]
#[doc = "You can use #VMA_ALLOCATION_CREATE_MAPPED_BIT with this usage type."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_ONLY: VmaMemoryUsage = 1;
#[doc = " Memory will be mappable on host."]
#[doc = "It usually means CPU (system) memory."]
#[doc = "Guarantees to be `HOST_VISIBLE` and `HOST_COHERENT`."]
#[doc = "CPU access is typically uncached. Writes may be write-combined."]
#[doc = "Resources created in this pool may still be accessible to the device, but access to them can be slow."]
#[doc = "It is roughly equivalent of `D3D12_HEAP_TYPE_UPLOAD`."]
#[doc = ""]
#[doc = "Usage: Staging copy of resources used as transfer source."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_ONLY: VmaMemoryUsage = 2;
#[doc = "Memory that is both mappable on host (guarantees to be `HOST_VISIBLE`) and preferably fast to access by GPU."]
#[doc = "CPU access is typically uncached. Writes may be write-combined."]
#[doc = ""]
#[doc = "Usage: Resources written frequently by host (dynamic), read by device. E.g. textures (with LINEAR layout), vertex buffers, uniform buffers updated every frame or every draw call."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_TO_GPU: VmaMemoryUsage = 3;
#[doc = " Memory mappable on host (guarantees to be `HOST_VISIBLE`) and cached."]
#[doc = "It is roughly equivalent of `D3D12_HEAP_TYPE_READBACK`."]
#[doc = ""]
#[doc = "Usage:"]
#[doc = ""]
#[doc = "- Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping."]
#[doc = "- Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_TO_CPU: VmaMemoryUsage = 4;
#[doc = " CPU memory - memory that is preferably not `DEVICE_LOCAL`, but also not guaranteed to be `HOST_VISIBLE`."]
#[doc = ""]
#[doc = "Usage: Staging copy of resources moved from GPU memory to CPU memory as part"]
#[doc = "of custom paging/residency mechanism, to be moved back to GPU memory when needed."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_CPU_COPY: VmaMemoryUsage = 5;
#[doc = " Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`."]
#[doc = "Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation."]
#[doc = ""]
#[doc = "Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`."]
#[doc = ""]
#[doc = "Allocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_GPU_LAZILY_ALLOCATED: VmaMemoryUsage = 6;
#[doc = " Lazily allocated GPU memory having `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`."]
#[doc = "Exists mostly on mobile platforms. Using it on desktop PC or other GPUs with no such memory type present will fail the allocation."]
#[doc = ""]
#[doc = "Usage: Memory for transient attachment images (color attachments, depth attachments etc.), created with `VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT`."]
#[doc = ""]
#[doc = "Allocations with this usage are always created as dedicated - it implies #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
pub const VmaMemoryUsage_VMA_MEMORY_USAGE_MAX_ENUM: VmaMemoryUsage = 2147483647;
#[doc = " \\brief Intended usage of the allocated memory."]
pub type VmaMemoryUsage = ::std::os::raw::c_uint;
#[doc = " \\brief Set this flag if the allocation should have its own memory block."]
#[doc = ""]
#[doc = "Use it for special, big resources, like fullscreen images used as attachments."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT:
    VmaAllocationCreateFlagBits = 1;
#[doc = " \\brief Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block."]
#[doc = ""]
#[doc = "If new allocation cannot be placed in any of the existing blocks, allocation"]
#[doc = "fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error."]
#[doc = ""]
#[doc = "You should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and"]
#[doc = "#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense."]
#[doc = ""]
#[doc = "If VmaAllocationCreateInfo::pool is not null, this flag is implied and ignored."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT:
    VmaAllocationCreateFlagBits = 2;
#[doc = " \\brief Set this flag to use a memory that will be persistently mapped and retrieve pointer to it."]
#[doc = ""]
#[doc = "Pointer to mapped memory will be returned through VmaAllocationInfo::pMappedData."]
#[doc = ""]
#[doc = "It is valid to use this flag for allocation made from memory type that is not"]
#[doc = "`HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is"]
#[doc = "useful if you need an allocation that is efficient to use on GPU"]
#[doc = "(`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that"]
#[doc = "support it (e.g. Intel GPU)."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_MAPPED_BIT:
    VmaAllocationCreateFlagBits = 4;
#[doc = " \\deprecated Removed. Do not use."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_RESERVED_1_BIT:
    VmaAllocationCreateFlagBits = 8;
#[doc = " \\deprecated Removed. Do not use."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_RESERVED_2_BIT:
    VmaAllocationCreateFlagBits = 16;
#[doc = " Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a"]
#[doc = "null-terminated string. Instead of copying pointer value, a local copy of the"]
#[doc = "string is made and stored in allocation's `pUserData`. The string is automatically"]
#[doc = "freed together with the allocation. It is also used in vmaBuildStatsString()."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT:
    VmaAllocationCreateFlagBits = 32;
#[doc = " Allocation will be created from upper stack in a double stack pool."]
#[doc = ""]
#[doc = "This flag is only allowed for custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT flag."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT:
    VmaAllocationCreateFlagBits = 64;
#[doc = " Create both buffer/image and allocation, but don't bind them together."]
#[doc = "It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions."]
#[doc = "The flag is meaningful only with functions that bind by default: vmaCreateBuffer(), vmaCreateImage()."]
#[doc = "Otherwise it is ignored."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_DONT_BIND_BIT:
    VmaAllocationCreateFlagBits = 128;
#[doc = " Create allocation only if additional device memory required for it, if any, won't exceed"]
#[doc = "memory budget. Otherwise return `VK_ERROR_OUT_OF_DEVICE_MEMORY`."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_WITHIN_BUDGET_BIT:
    VmaAllocationCreateFlagBits = 256;
#[doc = " \\brief Set this flag if the allocated memory will have aliasing resources."]
#[doc = ""]
#[doc = "Usage of this flag prevents supplying `VkMemoryDedicatedAllocateInfoKHR` when #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT is specified."]
#[doc = "Otherwise created dedicated memory will not be suitable for aliasing resources, resulting in Vulkan Validation Layer errors."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_CAN_ALIAS_BIT:
    VmaAllocationCreateFlagBits = 512;
#[doc = " Allocation strategy that chooses smallest possible free range for the allocation"]
#[doc = "to minimize memory usage and fragmentation, possibly at the expense of allocation time."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT:
    VmaAllocationCreateFlagBits = 65536;
#[doc = " Allocation strategy that chooses first suitable free range for the allocation -"]
#[doc = "not necessarily in terms of the smallest offset but the one that is easiest and fastest to find"]
#[doc = "to minimize allocation time, possibly at the expense of allocation quality."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT:
    VmaAllocationCreateFlagBits = 131072;
#[doc = " Alias to #VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT:
    VmaAllocationCreateFlagBits = 65536;
#[doc = " Alias to #VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT:
    VmaAllocationCreateFlagBits = 131072;
#[doc = " A bit mask to extract only `STRATEGY` bits from entire set of flags."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_STRATEGY_MASK:
    VmaAllocationCreateFlagBits = 196608;
#[doc = " A bit mask to extract only `STRATEGY` bits from entire set of flags."]
pub const VmaAllocationCreateFlagBits_VMA_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM:
    VmaAllocationCreateFlagBits = 2147483647;
#[doc = " Flags to be passed as VmaAllocationCreateInfo::flags."]
pub type VmaAllocationCreateFlagBits = ::std::os::raw::c_uint;
pub type VmaAllocationCreateFlags = Flags;
#[doc = " \\brief Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored."]
#[doc = ""]
#[doc = "This is an optional optimization flag."]
#[doc = ""]
#[doc = "If you always allocate using vmaCreateBuffer(), vmaCreateImage(),"]
#[doc = "vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator"]
#[doc = "knows exact type of your allocations so it can handle Buffer-Image Granularity"]
#[doc = "in the optimal way."]
#[doc = ""]
#[doc = "If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(),"]
#[doc = "exact type of such allocations is not known, so allocator must be conservative"]
#[doc = "in handling Buffer-Image Granularity, which can lead to suboptimal allocation"]
#[doc = "(wasted memory). In that case, if you can make sure you always allocate only"]
#[doc = "buffers and linear images or only optimal images out of this pool, use this flag"]
#[doc = "to make allocator disregard Buffer-Image Granularity and so make allocations"]
#[doc = "faster and more optimal."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT:
    VmaPoolCreateFlagBits = 2;
#[doc = " \\brief Enables alternative, linear allocation algorithm in this pool."]
#[doc = ""]
#[doc = "Specify this flag to enable linear allocation algorithm, which always creates"]
#[doc = "new allocations after last one and doesn't reuse space from allocations freed in"]
#[doc = "between. It trades memory consumption for simplified algorithm and data"]
#[doc = "structure, which has better performance and uses less memory for metadata."]
#[doc = ""]
#[doc = "By using this flag, you can achieve behavior of free-at-once, stack,"]
#[doc = "ring buffer, and double stack."]
#[doc = "For details, see documentation chapter \\ref linear_algorithm."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT: VmaPoolCreateFlagBits = 4;
#[doc = " \\brief Enables alternative, buddy allocation algorithm in this pool."]
#[doc = ""]
#[doc = "It operates on a tree of blocks, each having size that is a power of two and"]
#[doc = "a half of its parent's size. Comparing to default algorithm, this one provides"]
#[doc = "faster allocation and deallocation and decreased external fragmentation,"]
#[doc = "at the expense of more memory wasted (internal fragmentation)."]
#[doc = "For details, see documentation chapter \\ref buddy_algorithm."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT: VmaPoolCreateFlagBits = 8;
#[doc = " \\brief Enables alternative, Two-Level Segregated Fit (TLSF) allocation algorithm in this pool."]
#[doc = ""]
#[doc = "This algorithm is based on 2-level lists dividing address space into smaller"]
#[doc = "chunks. The first level is aligned to power of two which serves as buckets for requested"]
#[doc = "memory to fall into, and the second level is lineary subdivided into lists of free memory."]
#[doc = "This algorithm aims to achieve bounded response time even in the worst case scenario."]
#[doc = "Allocation time can be sometimes slightly longer than compared to other algorithms"]
#[doc = "but in return the application can avoid stalls in case of fragmentation, giving"]
#[doc = "predictable results, suitable for real-time use cases."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_TLSF_ALGORITHM_BIT: VmaPoolCreateFlagBits = 16;
#[doc = " Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_ALGORITHM_MASK: VmaPoolCreateFlagBits = 28;
#[doc = " Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaPoolCreateFlagBits_VMA_POOL_CREATE_FLAG_BITS_MAX_ENUM: VmaPoolCreateFlagBits =
    2147483647;
#[doc = " Flags to be passed as VmaPoolCreateInfo::flags."]
pub type VmaPoolCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " Flags to be passed as VmaPoolCreateInfo::flags. See #VmaPoolCreateFlagBits."]
pub type VmaPoolCreateFlags = Flags;
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_INCREMENTAL:
    VmaDefragmentationFlagBits = 1;
pub const VmaDefragmentationFlagBits_VMA_DEFRAGMENTATION_FLAG_BITS_MAX_ENUM:
    VmaDefragmentationFlagBits = 2147483647;
#[doc = " Flags to be used in vmaDefragmentationBegin(). None at the moment. Reserved for future use."]
pub type VmaDefragmentationFlagBits = ::std::os::raw::c_uint;
pub type VmaDefragmentationFlags = Flags;
#[doc = " \\brief Enables alternative, linear allocation algorithm in this virtual block."]
#[doc = ""]
#[doc = "Specify this flag to enable linear allocation algorithm, which always creates"]
#[doc = "new allocations after last one and doesn't reuse space from allocations freed in"]
#[doc = "between. It trades memory consumption for simplified algorithm and data"]
#[doc = "structure, which has better performance and uses less memory for metadata."]
#[doc = ""]
#[doc = "By using this flag, you can achieve behavior of free-at-once, stack,"]
#[doc = "ring buffer, and double stack."]
#[doc = "For details, see documentation chapter \\ref linear_algorithm."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT:
    VmaVirtualBlockCreateFlagBits = 1;
#[doc = " \\brief Enables alternative, buddy allocation algorithm in this virtual block."]
#[doc = ""]
#[doc = "It operates on a tree of blocks, each having size that is a power of two and"]
#[doc = "a half of its parent's size. Comparing to default algorithm, this one provides"]
#[doc = "faster allocation and deallocation and decreased external fragmentation,"]
#[doc = "at the expense of more memory wasted (internal fragmentation)."]
#[doc = "For details, see documentation chapter \\ref buddy_algorithm."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_BUDDY_ALGORITHM_BIT:
    VmaVirtualBlockCreateFlagBits = 2;
#[doc = " \\brief Enables alternative, TLSF allocation algorithm in virtual block."]
#[doc = ""]
#[doc = "This algorithm is based on 2-level lists dividing address space into smaller"]
#[doc = "chunks. The first level is aligned to power of two which serves as buckets for requested"]
#[doc = "memory to fall into, and the second level is lineary subdivided into lists of free memory."]
#[doc = "This algorithm aims to achieve bounded response time even in the worst case scenario."]
#[doc = "Allocation time can be sometimes slightly longer than compared to other algorithms"]
#[doc = "but in return the application can avoid stalls in case of fragmentation, giving"]
#[doc = "predictable results, suitable for real-time use cases."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_TLSF_ALGORITHM_BIT:
    VmaVirtualBlockCreateFlagBits = 4;
#[doc = " \\brief Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_ALGORITHM_MASK:
    VmaVirtualBlockCreateFlagBits = 7;
#[doc = " \\brief Bit mask to extract only `ALGORITHM` bits from entire set of flags."]
pub const VmaVirtualBlockCreateFlagBits_VMA_VIRTUAL_BLOCK_CREATE_FLAG_BITS_MAX_ENUM:
    VmaVirtualBlockCreateFlagBits = 2147483647;
#[doc = " Flags to be passed as VmaVirtualBlockCreateInfo::flags."]
pub type VmaVirtualBlockCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " Flags to be passed as VmaVirtualBlockCreateInfo::flags. See #VmaVirtualBlockCreateFlagBits."]
pub type VmaVirtualBlockCreateFlags = Flags;
#[doc = " \\brief Allocation will be created from upper stack in a double stack pool."]
#[doc = ""]
#[doc = "This flag is only allowed for virtual blocks created with #VMA_VIRTUAL_BLOCK_CREATE_LINEAR_ALGORITHM_BIT flag."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_UPPER_ADDRESS_BIT:
    VmaVirtualAllocationCreateFlagBits = 64;
#[doc = " \\brief Allocation strategy that tries to minimize memory usage."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT : VmaVirtualAllocationCreateFlagBits = 65536 ;
#[doc = " \\brief Allocation strategy that tries to minimize allocation time."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT:
    VmaVirtualAllocationCreateFlagBits = 131072;
#[doc = " \\brief A bit mask to extract only `STRATEGY` bits from entire set of flags."]
#[doc = ""]
#[doc = "These strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_STRATEGY_MASK:
    VmaVirtualAllocationCreateFlagBits = 196608;
#[doc = " \\brief A bit mask to extract only `STRATEGY` bits from entire set of flags."]
#[doc = ""]
#[doc = "These strategy flags are binary compatible with equivalent flags in #VmaAllocationCreateFlagBits."]
pub const VmaVirtualAllocationCreateFlagBits_VMA_VIRTUAL_ALLOCATION_CREATE_FLAG_BITS_MAX_ENUM:
    VmaVirtualAllocationCreateFlagBits = 2147483647;
#[doc = " Flags to be passed as VmaVirtualAllocationCreateInfo::flags."]
pub type VmaVirtualAllocationCreateFlagBits = ::std::os::raw::c_uint;
#[doc = " Flags to be passed as VmaVirtualAllocationCreateInfo::flags. See #VmaVirtualAllocationCreateFlagBits."]
pub type VmaVirtualAllocationCreateFlags = Flags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocator_T {
    _unused: [u8; 0],
}
pub type VmaAllocator = *mut VmaAllocator_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaPool_T {
    _unused: [u8; 0],
}
pub type VmaPool = *mut VmaPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocation_T {
    _unused: [u8; 0],
}
pub type VmaAllocation = *mut VmaAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationContext_T {
    _unused: [u8; 0],
}
pub type VmaDefragmentationContext = *mut VmaDefragmentationContext_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualAllocation_T {
    _unused: [u8; 0],
}
pub type VmaVirtualAllocation = *mut VmaVirtualAllocation_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaVirtualBlock_T {
    _unused: [u8; 0],
}
pub type VmaVirtualBlock = *mut VmaVirtualBlock_T;
#[doc = " Callback function called after successful vkAllocateMemory."]
pub type PFN_vmaAllocateDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: DeviceMemory,
        size: DeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback function called before vkFreeMemory."]
pub type PFN_vmaFreeDeviceMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(
        allocator: VmaAllocator,
        memoryType: u32,
        memory: DeviceMemory,
        size: DeviceSize,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " \\brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`."]
#[doc = ""]
#[doc = "Provided for informative purpose, e.g. to gather statistics about number of"]
#[doc = "allocations or total amount of memory allocated in Vulkan."]
#[doc = ""]
#[doc = "Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDeviceMemoryCallbacks {
    #[doc = " Optional, can be null."]
    pub pfnAllocate: PFN_vmaAllocateDeviceMemoryFunction,
    #[doc = " Optional, can be null."]
    pub pfnFree: PFN_vmaFreeDeviceMemoryFunction,
    #[doc = " Optional, can be null."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[doc = " \\brief Pointers to some Vulkan functions - a subset used by the library."]
#[doc = ""]
#[doc = "Used in VmaAllocatorCreateInfo::pVulkanFunctions."]
#[repr(C)]
pub struct VmaVulkanFunctions {
    #[doc = " Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetInstanceProcAddr: PFN_vkGetInstanceProcAddr,
    #[doc = " Required when using VMA_DYNAMIC_VULKAN_FUNCTIONS."]
    pub vkGetDeviceProcAddr: PFN_vkGetDeviceProcAddr,
    pub vkGetPhysicalDeviceProperties: PFN_vkGetPhysicalDeviceProperties,
    pub vkGetPhysicalDeviceMemoryProperties: PFN_vkGetPhysicalDeviceMemoryProperties,
    pub vkAllocateMemory: PFN_vkAllocateMemory,
    pub vkFreeMemory: PFN_vkFreeMemory,
    pub vkMapMemory: PFN_vkMapMemory,
    pub vkUnmapMemory: PFN_vkUnmapMemory,
    pub vkFlushMappedMemoryRanges: PFN_vkFlushMappedMemoryRanges,
    pub vkInvalidateMappedMemoryRanges: PFN_vkInvalidateMappedMemoryRanges,
    pub vkBindBufferMemory: PFN_vkBindBufferMemory,
    pub vkBindImageMemory: PFN_vkBindImageMemory,
    pub vkGetBufferMemoryRequirements: PFN_vkGetBufferMemoryRequirements,
    pub vkGetImageMemoryRequirements: PFN_vkGetImageMemoryRequirements,
    pub vkCreateBuffer: PFN_vkCreateBuffer,
    pub vkDestroyBuffer: PFN_vkDestroyBuffer,
    pub vkCreateImage: PFN_vkCreateImage,
    pub vkDestroyImage: PFN_vkDestroyImage,
    pub vkCmdCopyBuffer: PFN_vkCmdCopyBuffer,
    #[doc = " Fetch \"vkGetBufferMemoryRequirements2\" on Vulkan >= 1.1, fetch \"vkGetBufferMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetBufferMemoryRequirements2KHR: PFN_vkGetBufferMemoryRequirements2,
    #[doc = " Fetch \"vkGetImageMemoryRequirements 2\" on Vulkan >= 1.1, fetch \"vkGetImageMemoryRequirements2KHR\" when using VK_KHR_dedicated_allocation extension."]
    pub vkGetImageMemoryRequirements2KHR: PFN_vkGetImageMemoryRequirements2,
    #[doc = " Fetch \"vkBindBufferMemory2\" on Vulkan >= 1.1, fetch \"vkBindBufferMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindBufferMemory2KHR: PFN_vkBindBufferMemory2,
    #[doc = " Fetch \"vkBindImageMemory2\" on Vulkan >= 1.1, fetch \"vkBindImageMemory2KHR\" when using VK_KHR_bind_memory2 extension."]
    pub vkBindImageMemory2KHR: PFN_vkBindImageMemory2,
    pub vkGetPhysicalDeviceMemoryProperties2KHR: PFN_vkGetPhysicalDeviceMemoryProperties2,
}
#[doc = " Description of a Allocator to be created."]
#[repr(C)]
pub struct VmaAllocatorCreateInfo<'a> {
    #[doc = " Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum."]
    pub flags: VmaAllocatorCreateFlags,
    #[doc = " Vulkan physical device."]
    #[doc = "** It must be valid throughout whole lifetime of created allocator. */"]
    pub physicalDevice: PhysicalDevice,
    #[doc = " Vulkan device."]
    #[doc = "** It must be valid throughout whole lifetime of created allocator. */"]
    pub device: Device,
    #[doc = " Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional."]
    #[doc = "** Set to 0 to use default, which is currently 256 MiB. */"]
    pub preferredLargeHeapBlockSize: DeviceSize,
    #[doc = " Custom CPU memory allocation callbacks. Optional."]
    #[doc = "** Optional, can be null. When specified, will also be used for all CPU-side memory allocations. */"]
    pub pAllocationCallbacks: *const AllocationCallbacks<'a>,
    #[doc = " Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional."]
    #[doc = "** Optional, can be null. */"]
    pub pDeviceMemoryCallbacks: *const VmaDeviceMemoryCallbacks,
    #[doc = " \\brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap."]
    #[doc = ""]
    #[doc = "If not NULL, it must be a pointer to an array of"]
    #[doc = "`VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on"]
    #[doc = "maximum number of bytes that can be allocated out of particular Vulkan memory"]
    #[doc = "heap."]
    #[doc = ""]
    #[doc = "Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that"]
    #[doc = "heap. This is also the default in case of `pHeapSizeLimit` = NULL."]
    #[doc = ""]
    #[doc = "If there is a limit defined for a heap:"]
    #[doc = ""]
    #[doc = "- If user tries to allocate more memory from that heap using this allocator,"]
    #[doc = "the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`."]
    #[doc = "- If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the"]
    #[doc = "value of this limit will be reported instead when using vmaGetMemoryProperties()."]
    #[doc = ""]
    #[doc = "Warning! Using this feature may not be equivalent to installing a GPU with"]
    #[doc = "smaller amount of memory, because graphics driver doesn't necessary fail new"]
    #[doc = "allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is"]
    #[doc = "exceeded. It may return success and just silently migrate some device memory"]
    #[doc = "blocks to system RAM. This driver behavior can also be controlled using"]
    #[doc = "VK_AMD_memory_overallocation_behavior extension."]
    pub pHeapSizeLimit: *const DeviceSize,
    #[doc = " \\brief Pointers to Vulkan functions. Can be null."]
    #[doc = ""]
    #[doc = "For details see [Pointers to Vulkan functions](@ref config_Vulkan_functions)."]
    pub pVulkanFunctions: *const VmaVulkanFunctions,
    #[doc = " \\brief Handle to Vulkan instance object."]
    #[doc = ""]
    #[doc = "Starting from version 3.0.0 this member is no longer optional, it must be set!"]
    pub instance: Instance,
    #[doc = " \\brief Optional. The highest version of Vulkan that the application is designed to use."]
    #[doc = ""]
    #[doc = "It must be a value in the format as created by macro `VK_MAKE_VERSION` or a constant like: `VK_API_VERSION_1_1`, `VK_API_VERSION_1_0`."]
    #[doc = "The patch version number specified is ignored. Only the major and minor versions are considered."]
    #[doc = "It must be less or equal (preferably equal) to value as passed to `vkCreateInstance` as `VkApplicationInfo::apiVersion`."]
    #[doc = "Only versions 1.0, 1.1, 1.2, 1.3 are supported by the current implementation."]
    #[doc = "Leaving it initialized to zero is equivalent to `VK_API_VERSION_1_0`."]
    pub vulkanApiVersion: u32,
    #[doc = " \\brief Either null or a pointer to an array of external memory handle types for each Vulkan memory type."]
    #[doc = ""]
    #[doc = "If not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryTypeCount`"]
    #[doc = "elements, defining external memory handle types of particular Vulkan memory type,"]
    #[doc = "to be passed using `VkExportMemoryAllocateInfoKHR`."]
    #[doc = ""]
    #[doc = "Any of the elements may be equal to 0, which means not to use `VkExportMemoryAllocateInfoKHR` on this memory type."]
    #[doc = "This is also the default in case of `pTypeExternalMemoryHandleTypes` = NULL."]
    pub pTypeExternalMemoryHandleTypes: *const ExternalMemoryHandleTypeFlagsKHR,
}
#[doc = " Information about existing #VmaAllocator object."]
#[repr(C)]
pub struct VmaAllocatorInfo {
    #[doc = " \\brief Handle to Vulkan instance object."]
    #[doc = ""]
    #[doc = "This is the same value as has been passed through VmaAllocatorCreateInfo::instance."]
    pub instance: Instance,
    #[doc = " \\brief Handle to Vulkan physical device object."]
    #[doc = ""]
    #[doc = "This is the same value as has been passed through VmaAllocatorCreateInfo::physicalDevice."]
    pub physicalDevice: PhysicalDevice,
    #[doc = " \\brief Handle to Vulkan device object."]
    #[doc = ""]
    #[doc = "This is the same value as has been passed through VmaAllocatorCreateInfo::device."]
    pub device: Device,
}
#[doc = " Calculated statistics of memory usage in entire allocator."]
#[repr(C)]
pub struct VmaStatInfo {
    #[doc = " Number of `VkDeviceMemory` Vulkan memory blocks allocated."]
    pub blockCount: u32,
    #[doc = " Number of #VmaAllocation allocation objects allocated."]
    pub allocationCount: u32,
    #[doc = " Number of free ranges of memory between allocations."]
    pub unusedRangeCount: u32,
    #[doc = " Total number of bytes occupied by all allocations."]
    pub usedBytes: DeviceSize,
    #[doc = " Total number of bytes occupied by unused ranges."]
    pub unusedBytes: DeviceSize,
    pub allocationSizeMin: DeviceSize,
    pub allocationSizeAvg: DeviceSize,
    pub allocationSizeMax: DeviceSize,
    pub unusedRangeSizeMin: DeviceSize,
    pub unusedRangeSizeAvg: DeviceSize,
    pub unusedRangeSizeMax: DeviceSize,
}
#[doc = " General statistics from current state of Allocator."]
#[repr(C)]
pub struct VmaStats {
    pub memoryType: [VmaStatInfo; 32usize],
    pub memoryHeap: [VmaStatInfo; 16usize],
    pub total: VmaStatInfo,
}
#[doc = " Statistics of current memory usage and available budget, in bytes, for specific memory heap."]
#[repr(C)]
pub struct VmaBudget {
    #[doc = " \\brief Sum size of all `VkDeviceMemory` blocks allocated from particular heap, in bytes."]
    pub blockBytes: DeviceSize,
    #[doc = " \\brief Sum size of all allocations created in particular heap, in bytes."]
    #[doc = ""]
    #[doc = "Usually less or equal than `blockBytes`."]
    #[doc = "Difference `blockBytes - allocationBytes` is the amount of memory allocated but unused -"]
    #[doc = "available for new allocations or wasted due to fragmentation."]
    pub allocationBytes: DeviceSize,
    #[doc = " \\brief Estimated current memory usage of the program, in bytes."]
    #[doc = ""]
    #[doc = "Fetched from system using `VK_EXT_memory_budget` extension if enabled."]
    #[doc = ""]
    #[doc = "It might be different than `blockBytes` (usually higher) due to additional implicit objects"]
    #[doc = "also occupying the memory, like swapchain, pipelines, descriptor heaps, command buffers, or"]
    #[doc = "`VkDeviceMemory` blocks allocated outside of this library, if any."]
    pub usage: DeviceSize,
    #[doc = " \\brief Estimated amount of memory available to the program, in bytes."]
    #[doc = ""]
    #[doc = "Fetched from system using `VK_EXT_memory_budget` extension if enabled."]
    #[doc = ""]
    #[doc = "It might be different (most probably smaller) than `VkMemoryHeap::size[heapIndex]` due to factors"]
    #[doc = "external to the program, like other programs also consuming system resources."]
    #[doc = "Difference `budget - usage` is the amount of additional memory that can probably"]
    #[doc = "be allocated without problems. Exceeding the budget may result in various problems."]
    pub budget: DeviceSize,
}
#[doc = "\\addtogroup group_alloc"]
#[doc = "@{"]
#[repr(C)]
pub struct VmaAllocationCreateInfo {
    #[doc = " Use #VmaAllocationCreateFlagBits enum."]
    pub flags: VmaAllocationCreateFlags,
    #[doc = " \\brief Intended usage of memory."]
    #[doc = ""]
    #[doc = "You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub usage: VmaMemoryUsage,
    #[doc = " \\brief Flags that must be set in a Memory Type chosen for an allocation."]
    #[doc = ""]
    #[doc = "Leave 0 if you specify memory requirements in other way. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub requiredFlags: MemoryPropertyFlags,
    #[doc = " \\brief Flags that preferably should be set in a memory type chosen for an allocation."]
    #[doc = ""]
    #[doc = "Set to 0 if no additional flags are preferred. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub preferredFlags: MemoryPropertyFlags,
    #[doc = " \\brief Bitmask containing one bit set for every memory type acceptable for this allocation."]
    #[doc = ""]
    #[doc = "Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if"]
    #[doc = "it meets other requirements specified by this structure, with no further"]
    #[doc = "restrictions on memory type index. \\n"]
    #[doc = "If `pool` is not null, this member is ignored."]
    pub memoryTypeBits: u32,
    #[doc = " \\brief Pool that this allocation should be created in."]
    #[doc = ""]
    #[doc = "Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members:"]
    #[doc = "`usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored."]
    pub pool: VmaPool,
    #[doc = " \\brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData()."]
    #[doc = ""]
    #[doc = "If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either"]
    #[doc = "null or pointer to a null-terminated string. The string will be then copied to"]
    #[doc = "internal buffer, so it doesn't need to be valid after allocation call."]
    pub pUserData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief A floating-point value between 0 and 1, indicating the priority of the allocation relative to other memory allocations."]
    #[doc = ""]
    #[doc = "It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object"]
    #[doc = "and this allocation ends up as dedicated or is explicitly forced as dedicated using #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
    #[doc = "Otherwise, it has the priority of a memory block where it is placed and this variable is ignored."]
    pub priority: f32,
}
#[doc = " Describes parameter of created #VmaPool."]
#[repr(C)]
pub struct VmaPoolCreateInfo {
    #[doc = " \\brief Vulkan memory type index to allocate this pool from."]
    pub memoryTypeIndex: u32,
    #[doc = " \\brief Use combination of #VmaPoolCreateFlagBits."]
    pub flags: VmaPoolCreateFlags,
    #[doc = " \\brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional."]
    #[doc = ""]
    #[doc = "Specify nonzero to set explicit, constant size of memory blocks used by this"]
    #[doc = "pool."]
    #[doc = ""]
    #[doc = "Leave 0 to use default and let the library manage block sizes automatically."]
    #[doc = "Sizes of particular blocks may vary."]
    #[doc = "In this case, the pool will also support dedicated allocations."]
    pub blockSize: DeviceSize,
    #[doc = " \\brief Minimum number of blocks to be always allocated in this pool, even if they stay empty."]
    #[doc = ""]
    #[doc = "Set to 0 to have no preallocated blocks and allow the pool be completely empty."]
    pub minBlockCount: usize,
    #[doc = " \\brief Maximum number of blocks that can be allocated in this pool. Optional."]
    #[doc = ""]
    #[doc = "Set to 0 to use default, which is `SIZE_MAX`, which means no limit."]
    #[doc = ""]
    #[doc = "Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated"]
    #[doc = "throughout whole lifetime of this pool."]
    pub maxBlockCount: usize,
    #[doc = " \\brief A floating-point value between 0 and 1, indicating the priority of the allocations in this pool relative to other memory allocations."]
    #[doc = ""]
    #[doc = "It is used only when #VMA_ALLOCATOR_CREATE_EXT_MEMORY_PRIORITY_BIT flag was used during creation of the #VmaAllocator object."]
    #[doc = "Otherwise, this variable is ignored."]
    pub priority: f32,
    #[doc = " \\brief Additional minimum alignment to be used for all allocations created from this pool. Can be 0."]
    #[doc = ""]
    #[doc = "Leave 0 (default) not to impose any additional alignment. If not 0, it must be a power of two."]
    #[doc = "It can be useful in cases where alignment returned by Vulkan by functions like `vkGetBufferMemoryRequirements` is not enough,"]
    #[doc = "e.g. when doing interop with OpenGL."]
    pub minAllocationAlignment: DeviceSize,
    #[doc = " \\brief Additional `pNext` chain to be attached to `VkMemoryAllocateInfo` used for every allocation made by this pool. Optional."]
    #[doc = ""]
    #[doc = "Optional, can be null. If not null, it must point to a `pNext` chain of structures that can be attached to `VkMemoryAllocateInfo`."]
    #[doc = "It can be useful for special needs such as adding `VkExportMemoryAllocateInfoKHR`."]
    #[doc = "Structures pointed by this member must remain alive and unchanged for the whole lifetime of the custom pool."]
    #[doc = ""]
    #[doc = "Please note that some structures, e.g. `VkMemoryPriorityAllocateInfoEXT`, `VkMemoryDedicatedAllocateInfoKHR`,"]
    #[doc = "can be attached automatically by this library when using other, more convenient of its features."]
    pub pMemoryAllocateNext: *mut ::std::os::raw::c_void,
}
#[doc = " Describes parameter of existing #VmaPool."]
#[repr(C)]
pub struct VmaPoolStats {
    #[doc = " \\brief Total amount of `VkDeviceMemory` allocated from Vulkan for this pool, in bytes."]
    pub size: DeviceSize,
    #[doc = " \\brief Total number of bytes in the pool not used by any #VmaAllocation."]
    pub unusedSize: DeviceSize,
    #[doc = " \\brief Number of #VmaAllocation objects created from this pool that were not destroyed."]
    pub allocationCount: usize,
    #[doc = " \\brief Number of continuous memory ranges in the pool not used by any #VmaAllocation."]
    pub unusedRangeCount: usize,
    #[doc = " \\brief Number of `VkDeviceMemory` blocks allocated for this pool."]
    pub blockCount: usize,
}
#[doc = " Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaAllocationInfo {
    #[doc = " \\brief Memory type index that this allocation was allocated from."]
    #[doc = ""]
    #[doc = "It never changes."]
    pub memoryType: u32,
    #[doc = " \\brief Handle to Vulkan memory object."]
    #[doc = ""]
    #[doc = "Same memory object can be shared by multiple allocations."]
    #[doc = ""]
    #[doc = "It can change after call to vmaDefragment() if this allocation is passed to the function."]
    pub deviceMemory: DeviceMemory,
    #[doc = " \\brief Offset in `VkDeviceMemory` object to the beginning of this allocation, in bytes. `(deviceMemory, offset)` pair is unique to this allocation."]
    #[doc = ""]
    #[doc = "You usually don't need to use this offset. If you create a buffer or an image together with the allocation using e.g. function"]
    #[doc = "vmaCreateBuffer(), vmaCreateImage(), functions that operate on these resources refer to the beginning of the buffer or image,"]
    #[doc = "not entire device memory block. Functions like vmaMapMemory(), vmaBindBufferMemory() also refer to the beginning of the allocation"]
    #[doc = "and apply this offset automatically."]
    #[doc = ""]
    #[doc = "It can change after call to vmaDefragment() if this allocation is passed to the function."]
    pub offset: DeviceSize,
    #[doc = " \\brief Size of this allocation, in bytes."]
    #[doc = ""]
    #[doc = "It never changes."]
    #[doc = ""]
    #[doc = "\\note Allocation size returned in this variable may be greater than the size"]
    #[doc = "requested for the resource e.g. as `VkBufferCreateInfo::size`. Whole size of the"]
    #[doc = "allocation is accessible for operations on memory e.g. using a pointer after"]
    #[doc = "mapping with vmaMapMemory(), but operations on the resource e.g. using"]
    #[doc = "`vkCmdCopyBuffer` must be limited to the size of the resource."]
    pub size: DeviceSize,
    #[doc = " \\brief Pointer to the beginning of this allocation as mapped data."]
    #[doc = ""]
    #[doc = "If the allocation hasn't been mapped using vmaMapMemory() and hasn't been"]
    #[doc = "created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value is null."]
    #[doc = ""]
    #[doc = "It can change after call to vmaMapMemory(), vmaUnmapMemory()."]
    #[doc = "It can also change after call to vmaDefragment() if this allocation is passed to the function."]
    pub pMappedData: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData()."]
    #[doc = ""]
    #[doc = "It can change after call to vmaSetAllocationUserData() for this allocation."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[doc = " \\brief Parameters for defragmentation."]
#[doc = ""]
#[doc = "To be used with function vmaDefragmentationBegin()."]
#[repr(C)]
pub struct VmaDefragmentationInfo2 {
    #[doc = " \\brief Reserved for future use. Should be 0."]
    pub flags: VmaDefragmentationFlags,
    #[doc = " \\brief Number of allocations in `pAllocations` array."]
    pub allocationCount: u32,
    #[doc = " \\brief Pointer to array of allocations that can be defragmented."]
    #[doc = ""]
    #[doc = "The array should have `allocationCount` elements."]
    #[doc = "The array should not contain nulls."]
    #[doc = "Elements in the array should be unique - same allocation cannot occur twice."]
    #[doc = "All allocations not present in this array are considered non-moveable during this defragmentation."]
    pub pAllocations: *mut VmaAllocation,
    #[doc = " \\brief Optional, output. Pointer to array that will be filled with information whether the allocation at certain index has been changed during defragmentation."]
    #[doc = ""]
    #[doc = "The array should have `allocationCount` elements."]
    #[doc = "You can pass null if you are not interested in this information."]
    pub pAllocationsChanged: *mut Bool32,
    #[doc = " \\brief Numer of pools in `pPools` array."]
    pub poolCount: u32,
    #[doc = " \\brief Either null or pointer to array of pools to be defragmented."]
    #[doc = ""]
    #[doc = "All the allocations in the specified pools can be moved during defragmentation"]
    #[doc = "and there is no way to check if they were really moved as in `pAllocationsChanged`,"]
    #[doc = "so you must query all the allocations in all these pools for new `VkDeviceMemory`"]
    #[doc = "and offset using vmaGetAllocationInfo() if you might need to recreate buffers"]
    #[doc = "and images bound to them."]
    #[doc = ""]
    #[doc = "The array should have `poolCount` elements."]
    #[doc = "The array should not contain nulls."]
    #[doc = "Elements in the array should be unique - same pool cannot occur twice."]
    #[doc = ""]
    #[doc = "Using this array is equivalent to specifying all allocations from the pools in `pAllocations`."]
    #[doc = "It might be more efficient."]
    pub pPools: *mut VmaPool,
    #[doc = " \\brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on CPU side, like `memcpy()`, `memmove()`."]
    #[doc = ""]
    #[doc = "`VK_WHOLE_SIZE` means no limit."]
    pub maxCpuBytesToMove: DeviceSize,
    #[doc = " \\brief Maximum number of allocations that can be moved to a different place using transfers on CPU side, like `memcpy()`, `memmove()`."]
    #[doc = ""]
    #[doc = "`UINT32_MAX` means no limit."]
    pub maxCpuAllocationsToMove: u32,
    #[doc = " \\brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on GPU side, posted to `commandBuffer`."]
    #[doc = ""]
    #[doc = "`VK_WHOLE_SIZE` means no limit."]
    pub maxGpuBytesToMove: DeviceSize,
    #[doc = " \\brief Maximum number of allocations that can be moved to a different place using transfers on GPU side, posted to `commandBuffer`."]
    #[doc = ""]
    #[doc = "`UINT32_MAX` means no limit."]
    pub maxGpuAllocationsToMove: u32,
    #[doc = " \\brief Optional. Command buffer where GPU copy commands will be posted."]
    #[doc = ""]
    #[doc = "If not null, it must be a valid command buffer handle that supports Transfer queue type."]
    #[doc = "It must be in the recording state and outside of a render pass instance."]
    #[doc = "You need to submit it and make sure it finished execution before calling vmaDefragmentationEnd()."]
    #[doc = ""]
    #[doc = "Passing null means that only CPU defragmentation will be performed."]
    pub commandBuffer: CommandBuffer,
}
#[repr(C)]
pub struct VmaDefragmentationPassMoveInfo {
    pub allocation: VmaAllocation,
    pub memory: DeviceMemory,
    pub offset: DeviceSize,
}
#[doc = " \\brief Parameters for incremental defragmentation steps."]
#[doc = ""]
#[doc = "To be used with function vmaBeginDefragmentationPass()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationPassInfo {
    pub moveCount: u32,
    pub pMoves: *mut VmaDefragmentationPassMoveInfo,
}
#[doc = " \\brief Deprecated. Optional configuration parameters to be passed to function vmaDefragment()."]
#[doc = ""]
#[doc = "\\deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead."]
#[repr(C)]
pub struct VmaDefragmentationInfo {
    #[doc = " \\brief Maximum total numbers of bytes that can be copied while moving allocations to different places."]
    #[doc = ""]
    #[doc = "Default is `VK_WHOLE_SIZE`, which means no limit."]
    pub maxBytesToMove: DeviceSize,
    #[doc = " \\brief Maximum number of allocations that can be moved to different place."]
    #[doc = ""]
    #[doc = "Default is `UINT32_MAX`, which means no limit."]
    pub maxAllocationsToMove: u32,
}
#[doc = " Statistics returned by function vmaDefragment()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VmaDefragmentationStats {
    #[doc = " Total number of bytes that have been copied while moving allocations to different places."]
    pub bytesMoved: DeviceSize,
    #[doc = " Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects."]
    pub bytesFreed: DeviceSize,
    #[doc = " Number of allocations that have been moved to different places."]
    pub allocationsMoved: u32,
    #[doc = " Number of empty `VkDeviceMemory` objects that have been released to the system."]
    pub deviceMemoryBlocksFreed: u32,
}
#[doc = " Parameters of created #VmaVirtualBlock object to be passed to vmaCreateVirtualBlock()."]
#[repr(C)]
pub struct VmaVirtualBlockCreateInfo<'a> {
    #[doc = " \\brief Total size of the virtual block."]
    #[doc = ""]
    #[doc = "Sizes can be expressed in bytes or any units you want as long as you are consistent in using them."]
    #[doc = "For example, if you allocate from some array of structures, 1 can mean single instance of entire structure."]
    pub size: DeviceSize,
    #[doc = " \\brief Use combination of #VmaVirtualBlockCreateFlagBits."]
    pub flags: VmaVirtualBlockCreateFlags,
    #[doc = " \\brief Custom CPU memory allocation callbacks. Optional."]
    #[doc = ""]
    #[doc = "Optional, can be null. When specified, they will be used for all CPU-side memory allocations."]
    pub pAllocationCallbacks: *const AllocationCallbacks<'a>,
}
#[doc = " Parameters of created virtual allocation to be passed to vmaVirtualAllocate()."]
#[repr(C)]
pub struct VmaVirtualAllocationCreateInfo {
    #[doc = " \\brief Size of the allocation."]
    #[doc = ""]
    #[doc = "Cannot be zero."]
    pub size: DeviceSize,
    #[doc = " \\brief Required alignment of the allocation. Optional."]
    #[doc = ""]
    #[doc = "Must be power of two. Special value 0 has the same meaning as 1 - means no special alignment is required, so allocation can start at any offset."]
    pub alignment: DeviceSize,
    #[doc = " \\brief Use combination of #VmaVirtualAllocationCreateFlagBits."]
    pub flags: VmaVirtualAllocationCreateFlags,
    #[doc = " \\brief Custom pointer to be associated with the allocation. Optional."]
    #[doc = ""]
    #[doc = "It can be any value and can be used for user-defined purposes. It can be fetched or changed later."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[doc = " Parameters of an existing virtual allocation, returned by vmaGetVirtualAllocationInfo()."]
#[repr(C)]
pub struct VmaVirtualAllocationInfo {
    #[doc = " \\brief Offset of the allocation."]
    #[doc = ""]
    #[doc = "Offset at which the allocation was made."]
    pub offset: DeviceSize,
    #[doc = " \\brief Size of the allocation."]
    #[doc = ""]
    #[doc = "Same value as passed in VmaVirtualAllocationCreateInfo::size."]
    pub size: DeviceSize,
    #[doc = " \\brief Custom pointer associated with the allocation."]
    #[doc = ""]
    #[doc = "Same value as passed in VmaVirtualAllocationCreateInfo::pUserData or to vmaSetVirtualAllocationUserData()."]
    pub pUserData: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[doc = " Creates #VmaAllocator object."]
    pub fn vmaCreateAllocator(
        pCreateInfo: *const VmaAllocatorCreateInfo,
        pAllocator: *mut VmaAllocator,
    ) -> Result;
}
extern "C" {
    #[doc = " Destroys allocator object."]
    pub fn vmaDestroyAllocator(allocator: VmaAllocator);
}
extern "C" {
    #[doc = " \\brief Returns information about existing #VmaAllocator object - handle to Vulkan device etc."]
    #[doc = ""]
    #[doc = "It might be useful if you want to keep just the #VmaAllocator handle and fetch other required handles to"]
    #[doc = "`VkPhysicalDevice`, `VkDevice` etc. every time using this function."]
    pub fn vmaGetAllocatorInfo(allocator: VmaAllocator, pAllocatorInfo: *mut VmaAllocatorInfo);
}
extern "C" {
    #[doc = "PhysicalDeviceProperties are fetched from physicalDevice by the allocator."]
    #[doc = "You can access it here, without fetching it again on your own."]
    pub fn vmaGetPhysicalDeviceProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceProperties: *mut *const PhysicalDeviceProperties,
    );
}
extern "C" {
    #[doc = "PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator."]
    #[doc = "You can access it here, without fetching it again on your own."]
    pub fn vmaGetMemoryProperties(
        allocator: VmaAllocator,
        ppPhysicalDeviceMemoryProperties: *mut *const PhysicalDeviceMemoryProperties,
    );
}
extern "C" {
    #[doc = "\\brief Given Memory Type Index, returns Property Flags of this memory type."]
    #[doc = ""]
    #[doc = "This is just a convenience function. Same information can be obtained using"]
    #[doc = "vmaGetMemoryProperties()."]
    pub fn vmaGetMemoryTypeProperties(
        allocator: VmaAllocator,
        memoryTypeIndex: u32,
        pFlags: *mut MemoryPropertyFlags,
    );
}
extern "C" {
    #[doc = " \\brief Sets index of the current frame."]
    pub fn vmaSetCurrentFrameIndex(allocator: VmaAllocator, frameIndex: u32);
}
extern "C" {
    #[doc = " \\brief Retrieves statistics from current state of the Allocator."]
    #[doc = ""]
    #[doc = "This function is called \"calculate\" not \"get\" because it has to traverse all"]
    #[doc = "internal data structures, so it may be quite slow. For faster but more brief statistics"]
    #[doc = "suitable to be called every frame or every allocation, use vmaGetHeapBudgets()."]
    #[doc = ""]
    #[doc = "Note that when using allocator from multiple threads, returned information may immediately"]
    #[doc = "become outdated."]
    pub fn vmaCalculateStats(allocator: VmaAllocator, pStats: *mut VmaStats);
}
extern "C" {
    #[doc = " \\brief Retrieves information about current memory budget for all memory heaps."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param[out] pBudgets Must point to array with number of elements at least equal to number of memory heaps in physical device used."]
    #[doc = ""]
    #[doc = "This function is called \"get\" not \"calculate\" because it is very fast, suitable to be called"]
    #[doc = "every frame or every allocation. For more detailed statistics use vmaCalculateStats()."]
    #[doc = ""]
    #[doc = "Note that when using allocator from multiple threads, returned information may immediately"]
    #[doc = "become outdated."]
    pub fn vmaGetHeapBudgets(allocator: VmaAllocator, pBudgets: *mut VmaBudget);
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo."]
    #[doc = ""]
    #[doc = "This algorithm tries to find a memory type that:"]
    #[doc = ""]
    #[doc = "- Is allowed by memoryTypeBits."]
    #[doc = "- Contains all the flags from pAllocationCreateInfo->requiredFlags."]
    #[doc = "- Matches intended usage."]
    #[doc = "- Has as many flags from pAllocationCreateInfo->preferredFlags as possible."]
    #[doc = ""]
    #[doc = "\\return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result"]
    #[doc = "from this function or any other allocating function probably means that your"]
    #[doc = "device doesn't support any memory type with requested features for the specific"]
    #[doc = "type of resource you want to use it for. Please check parameters of your"]
    #[doc = "resource, like image layout (OPTIMAL versus LINEAR) or mip level count."]
    pub fn vmaFindMemoryTypeIndex(
        allocator: VmaAllocator,
        memoryTypeBits: u32,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo."]
    #[doc = ""]
    #[doc = "It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex."]
    #[doc = "It internally creates a temporary, dummy buffer that never has memory bound."]
    #[doc = "It is just a convenience function, equivalent to calling:"]
    #[doc = ""]
    #[doc = "- `vkCreateBuffer`"]
    #[doc = "- `vkGetBufferMemoryRequirements`"]
    #[doc = "- `vmaFindMemoryTypeIndex`"]
    #[doc = "- `vkDestroyBuffer`"]
    pub fn vmaFindMemoryTypeIndexForBufferInfo(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
extern "C" {
    #[doc = "\\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo."]
    #[doc = ""]
    #[doc = "It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex."]
    #[doc = "It internally creates a temporary, dummy image that never has memory bound."]
    #[doc = "It is just a convenience function, equivalent to calling:"]
    #[doc = ""]
    #[doc = "- `vkCreateImage`"]
    #[doc = "- `vkGetImageMemoryRequirements`"]
    #[doc = "- `vmaFindMemoryTypeIndex`"]
    #[doc = "- `vkDestroyImage`"]
    pub fn vmaFindMemoryTypeIndexForImageInfo(
        allocator: VmaAllocator,
        pImageCreateInfo: *const ImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pMemoryTypeIndex: *mut u32,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Allocates Vulkan device memory and creates #VmaPool object."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pCreateInfo Parameters of pool to create."]
    #[doc = "\\param[out] pPool Handle to created pool."]
    pub fn vmaCreatePool(
        allocator: VmaAllocator,
        pCreateInfo: *const VmaPoolCreateInfo,
        pPool: *mut VmaPool,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Destroys #VmaPool object and frees Vulkan device memory."]
    pub fn vmaDestroyPool(allocator: VmaAllocator, pool: VmaPool);
}
extern "C" {
    #[doc = " \\brief Retrieves statistics of existing #VmaPool object."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pool Pool object."]
    #[doc = "\\param[out] pPoolStats Statistics of specified pool."]
    pub fn vmaGetPoolStats(allocator: VmaAllocator, pool: VmaPool, pPoolStats: *mut VmaPoolStats);
}
extern "C" {
    #[doc = " \\brief Checks magic number in margins around all allocations in given memory pool in search for corruptions."]
    #[doc = ""]
    #[doc = "Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,"]
    #[doc = "`VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is"]
    #[doc = "`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection)."]
    #[doc = ""]
    #[doc = "Possible return values:"]
    #[doc = ""]
    #[doc = "- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool."]
    #[doc = "- `VK_SUCCESS` - corruption detection has been performed and succeeded."]
    #[doc = "- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations."]
    #[doc = "`VMA_ASSERT` is also fired in that case."]
    #[doc = "- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckPoolCorruption(allocator: VmaAllocator, pool: VmaPool) -> Result;
}
extern "C" {
    #[doc = " \\brief Retrieves name of a custom pool."]
    #[doc = ""]
    #[doc = "After the call `ppName` is either null or points to an internally-owned null-terminated string"]
    #[doc = "containing name of the pool that was previously set. The pointer becomes invalid when the pool is"]
    #[doc = "destroyed or its name is changed using vmaSetPoolName()."]
    pub fn vmaGetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        ppName: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Sets name of a custom pool."]
    #[doc = ""]
    #[doc = "`pName` can be either null or pointer to a null-terminated string with new name for the pool."]
    #[doc = "Function makes internal copy of the string, so it can be changed or freed immediately after this call."]
    pub fn vmaSetPoolName(
        allocator: VmaAllocator,
        pool: VmaPool,
        pName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief General purpose memory allocation."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param pVkMemoryRequirements"]
    #[doc = "\\param pCreateInfo"]
    #[doc = "\\param[out] pAllocation Handle to allocated memory."]
    #[doc = "\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo()."]
    #[doc = ""]
    #[doc = "You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages()."]
    #[doc = ""]
    #[doc = "It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(),"]
    #[doc = "vmaCreateBuffer(), vmaCreateImage() instead whenever possible."]
    pub fn vmaAllocateMemory(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const MemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief General purpose memory allocation for multiple allocation objects at once."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pVkMemoryRequirements Memory requirements for each allocation."]
    #[doc = "\\param pCreateInfo Creation parameters for each allocation."]
    #[doc = "\\param allocationCount Number of allocations to make."]
    #[doc = "\\param[out] pAllocations Pointer to array that will be filled with handles to created allocations."]
    #[doc = "\\param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters of created allocations."]
    #[doc = ""]
    #[doc = "You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages()."]
    #[doc = ""]
    #[doc = "Word \"pages\" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding."]
    #[doc = "It is just a general purpose allocation function able to make multiple allocations at once."]
    #[doc = "It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times."]
    #[doc = ""]
    #[doc = "All allocations are made using same parameters. All of them are created out of the same memory pool and type."]
    #[doc = "If any allocation fails, all allocations already made within this function call are also freed, so that when"]
    #[doc = "returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`."]
    pub fn vmaAllocateMemoryPages(
        allocator: VmaAllocator,
        pVkMemoryRequirements: *const MemoryRequirements,
        pCreateInfo: *const VmaAllocationCreateInfo,
        allocationCount: usize,
        pAllocations: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    #[doc = "\\param allocator"]
    #[doc = "\\param buffer"]
    #[doc = "\\param pCreateInfo"]
    #[doc = "\\param[out] pAllocation Handle to allocated memory."]
    #[doc = "\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo()."]
    #[doc = ""]
    #[doc = "You should free the memory using vmaFreeMemory()."]
    pub fn vmaAllocateMemoryForBuffer(
        allocator: VmaAllocator,
        buffer: Buffer,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    #[doc = " Function similar to vmaAllocateMemoryForBuffer()."]
    pub fn vmaAllocateMemoryForImage(
        allocator: VmaAllocator,
        image: Image,
        pCreateInfo: *const VmaAllocationCreateInfo,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage()."]
    #[doc = ""]
    #[doc = "Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped."]
    pub fn vmaFreeMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Frees memory and destroys multiple allocations."]
    #[doc = ""]
    #[doc = "Word \"pages\" is just a suggestion to use this function to free pieces of memory used for sparse binding."]
    #[doc = "It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(),"]
    #[doc = "vmaAllocateMemoryPages() and other functions."]
    #[doc = "It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times."]
    #[doc = ""]
    #[doc = "Allocations in `pAllocations` array can come from any memory pools and types."]
    #[doc = "Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped."]
    pub fn vmaFreeMemoryPages(
        allocator: VmaAllocator,
        allocationCount: usize,
        pAllocations: *mut VmaAllocation,
    );
}
extern "C" {
    #[doc = " \\brief Returns current information about specified allocation."]
    #[doc = ""]
    #[doc = "Current paramteres of given allocation are returned in `pAllocationInfo`."]
    #[doc = ""]
    #[doc = "Although this function doesn't lock any mutex, so it should be quite efficient,"]
    #[doc = "you should avoid calling it too often."]
    #[doc = "You can retrieve same VmaAllocationInfo structure while creating your resource, from function"]
    #[doc = "vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change"]
    #[doc = "(e.g. due to defragmentation)."]
    pub fn vmaGetAllocationInfo(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    );
}
extern "C" {
    #[doc = " \\brief Sets pUserData in given allocation to new value."]
    #[doc = ""]
    #[doc = "If the allocation was created with VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT,"]
    #[doc = "pUserData must be either null, or pointer to a null-terminated string. The function"]
    #[doc = "makes local copy of the string and sets it as allocation's `pUserData`. String"]
    #[doc = "passed as pUserData doesn't need to be valid for whole lifetime of the allocation -"]
    #[doc = "you can free it after this call. String previously pointed by allocation's"]
    #[doc = "pUserData is freed from memory."]
    #[doc = ""]
    #[doc = "If the flag was not used, the value of pointer `pUserData` is just copied to"]
    #[doc = "allocation's `pUserData`. It is opaque, so you can use it however you want - e.g."]
    #[doc = "as a pointer, ordinal number or some handle to you own data."]
    pub fn vmaSetAllocationUserData(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "\\brief Given an allocation, returns Property Flags of its memory type."]
    #[doc = ""]
    #[doc = "This is just a convenience function. Same information can be obtained using"]
    #[doc = "vmaGetAllocationInfo() + vmaGetMemoryProperties()."]
    pub fn vmaGetAllocationMemoryProperties(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        pFlags: *mut MemoryPropertyFlags,
    );
}
extern "C" {
    #[doc = " \\brief Maps memory represented by given allocation and returns pointer to it."]
    #[doc = ""]
    #[doc = "Maps memory represented by given allocation to make it accessible to CPU code."]
    #[doc = "When succeeded, `*ppData` contains pointer to first byte of this memory."]
    #[doc = ""]
    #[doc = "\\warning"]
    #[doc = "If the allocation is part of a bigger `VkDeviceMemory` block, returned pointer is"]
    #[doc = "correctly offsetted to the beginning of region assigned to this particular allocation."]
    #[doc = "Unlike the result of `vkMapMemory`, it points to the allocation, not to the beginning of the whole block."]
    #[doc = "You should not add VmaAllocationInfo::offset to it!"]
    #[doc = ""]
    #[doc = "Mapping is internally reference-counted and synchronized, so despite raw Vulkan"]
    #[doc = "function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory`"]
    #[doc = "multiple times simultaneously, it is safe to call this function on allocations"]
    #[doc = "assigned to the same memory block. Actual Vulkan memory will be mapped on first"]
    #[doc = "mapping and unmapped on last unmapping."]
    #[doc = ""]
    #[doc = "If the function succeeded, you must call vmaUnmapMemory() to unmap the"]
    #[doc = "allocation when mapping is no longer needed or before freeing the allocation, at"]
    #[doc = "the latest."]
    #[doc = ""]
    #[doc = "It also safe to call this function multiple times on the same allocation. You"]
    #[doc = "must call vmaUnmapMemory() same number of times as you called vmaMapMemory()."]
    #[doc = ""]
    #[doc = "It is also safe to call this function on allocation created with"]
    #[doc = "#VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time."]
    #[doc = "You must still call vmaUnmapMemory() same number of times as you called"]
    #[doc = "vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the"]
    #[doc = "\"0-th\" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag."]
    #[doc = ""]
    #[doc = "This function fails when used on allocation made in memory type that is not"]
    #[doc = "`HOST_VISIBLE`."]
    #[doc = ""]
    #[doc = "This function doesn't automatically flush or invalidate caches."]
    #[doc = "If the allocation is made from a memory types that is not `HOST_COHERENT`,"]
    #[doc = "you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaMapMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory()."]
    #[doc = ""]
    #[doc = "For details, see description of vmaMapMemory()."]
    #[doc = ""]
    #[doc = "This function doesn't automatically flush or invalidate caches."]
    #[doc = "If the allocation is made from a memory types that is not `HOST_COHERENT`,"]
    #[doc = "you also need to use vmaInvalidateAllocation() / vmaFlushAllocation(), as required by Vulkan specification."]
    pub fn vmaUnmapMemory(allocator: VmaAllocator, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Flushes memory of given allocation."]
    #[doc = ""]
    #[doc = "Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation."]
    #[doc = "It needs to be called after writing to a mapped memory for memory types that are not `HOST_COHERENT`."]
    #[doc = "Unmap operation doesn't do that automatically."]
    #[doc = ""]
    #[doc = "- `offset` must be relative to the beginning of allocation."]
    #[doc = "- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation."]
    #[doc = "- `offset` and `size` don't have to be aligned."]
    #[doc = "They are internally rounded down/up to multiply of `nonCoherentAtomSize`."]
    #[doc = "- If `size` is 0, this call is ignored."]
    #[doc = "- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,"]
    #[doc = "this call is ignored."]
    #[doc = ""]
    #[doc = "Warning! `offset` and `size` are relative to the contents of given `allocation`."]
    #[doc = "If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively."]
    #[doc = "Do not pass allocation's offset as `offset`!!!"]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is"]
    #[doc = "called, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: DeviceSize,
        size: DeviceSize,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Invalidates memory of given allocation."]
    #[doc = ""]
    #[doc = "Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation."]
    #[doc = "It needs to be called before reading from a mapped memory for memory types that are not `HOST_COHERENT`."]
    #[doc = "Map operation doesn't do that automatically."]
    #[doc = ""]
    #[doc = "- `offset` must be relative to the beginning of allocation."]
    #[doc = "- `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation."]
    #[doc = "- `offset` and `size` don't have to be aligned."]
    #[doc = "They are internally rounded down/up to multiply of `nonCoherentAtomSize`."]
    #[doc = "- If `size` is 0, this call is ignored."]
    #[doc = "- If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`,"]
    #[doc = "this call is ignored."]
    #[doc = ""]
    #[doc = "Warning! `offset` and `size` are relative to the contents of given `allocation`."]
    #[doc = "If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively."]
    #[doc = "Do not pass allocation's offset as `offset`!!!"]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if"]
    #[doc = "it is called, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocation(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        offset: DeviceSize,
        size: DeviceSize,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Flushes memory of given set of allocations."]
    #[doc = ""]
    #[doc = "Calls `vkFlushMappedMemoryRanges()` for memory associated with given ranges of given allocations."]
    #[doc = "For more information, see documentation of vmaFlushAllocation()."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocationCount"]
    #[doc = "\\param allocations"]
    #[doc = "\\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero."]
    #[doc = "\\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations."]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkFlushMappedMemoryRanges` if it is"]
    #[doc = "called, otherwise `VK_SUCCESS`."]
    pub fn vmaFlushAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *mut VmaAllocation,
        offsets: *const DeviceSize,
        sizes: *const DeviceSize,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Invalidates memory of given set of allocations."]
    #[doc = ""]
    #[doc = "Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given ranges of given allocations."]
    #[doc = "For more information, see documentation of vmaInvalidateAllocation()."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocationCount"]
    #[doc = "\\param allocations"]
    #[doc = "\\param offsets If not null, it must point to an array of offsets of regions to flush, relative to the beginning of respective allocations. Null means all ofsets are zero."]
    #[doc = "\\param sizes If not null, it must point to an array of sizes of regions to flush in respective allocations. Null means `VK_WHOLE_SIZE` for all allocations."]
    #[doc = ""]
    #[doc = "This function returns the `VkResult` from `vkInvalidateMappedMemoryRanges` if it is"]
    #[doc = "called, otherwise `VK_SUCCESS`."]
    pub fn vmaInvalidateAllocations(
        allocator: VmaAllocator,
        allocationCount: u32,
        allocations: *mut VmaAllocation,
        offsets: *const DeviceSize,
        sizes: *const DeviceSize,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param memoryTypeBits Bit mask, where each bit set means that a memory type with that index should be checked."]
    #[doc = ""]
    #[doc = "Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero,"]
    #[doc = "`VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are"]
    #[doc = "`HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection)."]
    #[doc = ""]
    #[doc = "Possible return values:"]
    #[doc = ""]
    #[doc = "- `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types."]
    #[doc = "- `VK_SUCCESS` - corruption detection has been performed and succeeded."]
    #[doc = "- `VK_ERROR_UNKNOWN` - corruption detection has been performed and found memory corruptions around one of the allocations."]
    #[doc = "`VMA_ASSERT` is also fired in that case."]
    #[doc = "- Other value: Error returned by Vulkan, e.g. memory mapping failure."]
    pub fn vmaCheckCorruption(allocator: VmaAllocator, memoryTypeBits: u32) -> Result;
}
extern "C" {
    #[doc = " \\brief Begins defragmentation process."]
    #[doc = ""]
    #[doc = "\\param allocator Allocator object."]
    #[doc = "\\param pInfo Structure filled with parameters of defragmentation."]
    #[doc = "\\param[out] pStats Optional. Statistics of defragmentation. You can pass null if you are not interested in this information."]
    #[doc = "\\param[out] pContext Context object that must be passed to vmaDefragmentationEnd() to finish defragmentation."]
    #[doc = "\\return `VK_SUCCESS` and `*pContext == null` if defragmentation finished within this function call. `VK_NOT_READY` and `*pContext != null` if defragmentation has been started and you need to call vmaDefragmentationEnd() to finish it. Negative value in case of error."]
    #[doc = ""]
    #[doc = "Use this function instead of old, deprecated vmaDefragment()."]
    #[doc = ""]
    #[doc = "Warning! Between the call to vmaDefragmentationBegin() and vmaDefragmentationEnd():"]
    #[doc = ""]
    #[doc = "- You should not use any of allocations passed as `pInfo->pAllocations` or"]
    #[doc = "any allocations that belong to pools passed as `pInfo->pPools`,"]
    #[doc = "including calling vmaGetAllocationInfo(), or access"]
    #[doc = "their data."]
    #[doc = "- Some mutexes protecting internal data structures may be locked, so trying to"]
    #[doc = "make or free any allocations, bind buffers or images, map memory, or launch"]
    #[doc = "another simultaneous defragmentation in between may cause stall (when done on"]
    #[doc = "another thread) or deadlock (when done on the same thread), unless you are"]
    #[doc = "100% sure that defragmented allocations are in different pools."]
    #[doc = "- Information returned via `pStats` and `pInfo->pAllocationsChanged` are undefined."]
    #[doc = "They become valid after call to vmaDefragmentationEnd()."]
    #[doc = "- If `pInfo->commandBuffer` is not null, you must submit that command buffer"]
    #[doc = "and make sure it finished execution before calling vmaDefragmentationEnd()."]
    #[doc = ""]
    #[doc = "For more information and important limitations regarding defragmentation, see documentation chapter:"]
    #[doc = "[Defragmentation](@ref defragmentation)."]
    pub fn vmaDefragmentationBegin(
        allocator: VmaAllocator,
        pInfo: *const VmaDefragmentationInfo2,
        pStats: *mut VmaDefragmentationStats,
        pContext: *mut VmaDefragmentationContext,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Ends defragmentation process."]
    #[doc = ""]
    #[doc = "Use this function to finish defragmentation started by vmaDefragmentationBegin()."]
    #[doc = "It is safe to pass `context == null`. The function then does nothing."]
    pub fn vmaDefragmentationEnd(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
    ) -> Result;
}
extern "C" {
    pub fn vmaBeginDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
        pInfo: *mut VmaDefragmentationPassInfo,
    ) -> Result;
}
extern "C" {
    pub fn vmaEndDefragmentationPass(
        allocator: VmaAllocator,
        context: VmaDefragmentationContext,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Deprecated. Compacts memory by moving allocations."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param pAllocations Array of allocations that can be moved during this compation."]
    #[doc = "\\param allocationCount Number of elements in pAllocations and pAllocationsChanged arrays."]
    #[doc = "\\param[out] pAllocationsChanged Array of boolean values that will indicate whether matching allocation in pAllocations array has been moved. This parameter is optional. Pass null if you don't need this information."]
    #[doc = "\\param pDefragmentationInfo Configuration parameters. Optional - pass null to use default values."]
    #[doc = "\\param[out] pDefragmentationStats Statistics returned by the function. Optional - pass null if you don't need this information."]
    #[doc = "\\return `VK_SUCCESS` if completed, negative error code in case of error."]
    #[doc = ""]
    #[doc = "\\deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead."]
    #[doc = ""]
    #[doc = "This function works by moving allocations to different places (different"]
    #[doc = "`VkDeviceMemory` objects and/or different offsets) in order to optimize memory"]
    #[doc = "usage. Only allocations that are in `pAllocations` array can be moved. All other"]
    #[doc = "allocations are considered nonmovable in this call. Basic rules:"]
    #[doc = ""]
    #[doc = "- Only allocations made in memory types that have"]
    #[doc = "`VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`"]
    #[doc = "flags can be compacted. You may pass other allocations but it makes no sense -"]
    #[doc = "these will never be moved."]
    #[doc = "- Custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT or"]
    #[doc = "#VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT flag are not defragmented. Allocations"]
    #[doc = "passed to this function that come from such pools are ignored."]
    #[doc = "- Allocations created with #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT or"]
    #[doc = "created as dedicated allocations for any other reason are also ignored."]
    #[doc = "- Both allocations made with or without #VMA_ALLOCATION_CREATE_MAPPED_BIT"]
    #[doc = "flag can be compacted. If not persistently mapped, memory will be mapped"]
    #[doc = "temporarily inside this function if needed."]
    #[doc = "- You must not pass same #VmaAllocation object multiple times in `pAllocations` array."]
    #[doc = ""]
    #[doc = "The function also frees empty `VkDeviceMemory` blocks."]
    #[doc = ""]
    #[doc = "Warning: This function may be time-consuming, so you shouldn't call it too often"]
    #[doc = "(like after every resource creation/destruction)."]
    #[doc = "You can call it on special occasions (like when reloading a game level or"]
    #[doc = "when you just destroyed a lot of objects). Calling it every frame may be OK, but"]
    #[doc = "you should measure that on your platform."]
    #[doc = ""]
    #[doc = "For more information, see [Defragmentation](@ref defragmentation) chapter."]
    pub fn vmaDefragment(
        allocator: VmaAllocator,
        pAllocations: *mut VmaAllocation,
        allocationCount: usize,
        pAllocationsChanged: *mut Bool32,
        pDefragmentationInfo: *const VmaDefragmentationInfo,
        pDefragmentationStats: *mut VmaDefragmentationStats,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Binds buffer to allocation."]
    #[doc = ""]
    #[doc = "Binds specified buffer to region of memory represented by specified allocation."]
    #[doc = "Gets `VkDeviceMemory` handle and offset from the allocation."]
    #[doc = "If you want to create a buffer, allocate memory for it and bind them together separately,"]
    #[doc = "you should use this function for binding instead of standard `vkBindBufferMemory()`,"]
    #[doc = "because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple"]
    #[doc = "allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously"]
    #[doc = "(which is illegal in Vulkan)."]
    #[doc = ""]
    #[doc = "It is recommended to use function vmaCreateBuffer() instead of this one."]
    pub fn vmaBindBufferMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        buffer: Buffer,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Binds buffer to allocation with additional parameters."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocation"]
    #[doc = "\\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0."]
    #[doc = "\\param buffer"]
    #[doc = "\\param pNext A chain of structures to be attached to `VkBindBufferMemoryInfoKHR` structure used internally. Normally it should be null."]
    #[doc = ""]
    #[doc = "This function is similar to vmaBindBufferMemory(), but it provides additional parameters."]
    #[doc = ""]
    #[doc = "If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag"]
    #[doc = "or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindBufferMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        buffer: Buffer,
        pNext: *const ::std::os::raw::c_void,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Binds image to allocation."]
    #[doc = ""]
    #[doc = "Binds specified image to region of memory represented by specified allocation."]
    #[doc = "Gets `VkDeviceMemory` handle and offset from the allocation."]
    #[doc = "If you want to create an image, allocate memory for it and bind them together separately,"]
    #[doc = "you should use this function for binding instead of standard `vkBindImageMemory()`,"]
    #[doc = "because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple"]
    #[doc = "allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously"]
    #[doc = "(which is illegal in Vulkan)."]
    #[doc = ""]
    #[doc = "It is recommended to use function vmaCreateImage() instead of this one."]
    pub fn vmaBindImageMemory(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        image: Image,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Binds image to allocation with additional parameters."]
    #[doc = ""]
    #[doc = "\\param allocator"]
    #[doc = "\\param allocation"]
    #[doc = "\\param allocationLocalOffset Additional offset to be added while binding, relative to the beginning of the `allocation`. Normally it should be 0."]
    #[doc = "\\param image"]
    #[doc = "\\param pNext A chain of structures to be attached to `VkBindImageMemoryInfoKHR` structure used internally. Normally it should be null."]
    #[doc = ""]
    #[doc = "This function is similar to vmaBindImageMemory(), but it provides additional parameters."]
    #[doc = ""]
    #[doc = "If `pNext` is not null, #VmaAllocator object must have been created with #VMA_ALLOCATOR_CREATE_KHR_BIND_MEMORY2_BIT flag"]
    #[doc = "or with VmaAllocatorCreateInfo::vulkanApiVersion `>= VK_API_VERSION_1_1`. Otherwise the call fails."]
    pub fn vmaBindImageMemory2(
        allocator: VmaAllocator,
        allocation: VmaAllocation,
        allocationLocalOffset: DeviceSize,
        image: Image,
        pNext: *const ::std::os::raw::c_void,
    ) -> Result;
}
extern "C" {
    #[doc = "\\param allocator"]
    #[doc = "\\param pBufferCreateInfo"]
    #[doc = "\\param pAllocationCreateInfo"]
    #[doc = "\\param[out] pBuffer Buffer that was created."]
    #[doc = "\\param[out] pAllocation Allocation that was created."]
    #[doc = "\\param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo()."]
    #[doc = ""]
    #[doc = "This function automatically:"]
    #[doc = ""]
    #[doc = "-# Creates buffer."]
    #[doc = "-# Allocates appropriate memory for it."]
    #[doc = "-# Binds the buffer with the memory."]
    #[doc = ""]
    #[doc = "If any of these operations fail, buffer and allocation are not created,"]
    #[doc = "returned value is negative error code, *pBuffer and *pAllocation are null."]
    #[doc = ""]
    #[doc = "If the function succeeded, you must destroy both buffer and allocation when you"]
    #[doc = "no longer need them using either convenience function vmaDestroyBuffer() or"]
    #[doc = "separately, using `vkDestroyBuffer()` and vmaFreeMemory()."]
    #[doc = ""]
    #[doc = "If #VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used,"]
    #[doc = "VK_KHR_dedicated_allocation extension is used internally to query driver whether"]
    #[doc = "it requires or prefers the new buffer to have dedicated allocation. If yes,"]
    #[doc = "and if dedicated allocation is possible"]
    #[doc = "(#VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated"]
    #[doc = "allocation for this buffer, just like when using"]
    #[doc = "#VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT."]
    #[doc = ""]
    #[doc = "\\note This function creates a new `VkBuffer`. Sub-allocation of parts of one large buffer,"]
    #[doc = "although recommended as a good practice, is out of scope of this library and could be implemented"]
    #[doc = "by the user as a higher-level logic on top of VMA."]
    pub fn vmaCreateBuffer(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pBuffer: *mut Buffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Creates a buffer with additional minimum alignment."]
    #[doc = ""]
    #[doc = "Similar to vmaCreateBuffer() but provides additional parameter `minAlignment` which allows to specify custom,"]
    #[doc = "minimum alignment to be used when placing the buffer inside a larger memory block, which may be needed e.g."]
    #[doc = "for interop with OpenGL."]
    pub fn vmaCreateBufferWithAlignment(
        allocator: VmaAllocator,
        pBufferCreateInfo: *const BufferCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        minAlignment: DeviceSize,
        pBuffer: *mut Buffer,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Destroys Vulkan buffer and frees allocated memory."]
    #[doc = ""]
    #[doc = "This is just a convenience function equivalent to:"]
    #[doc = ""]
    #[doc = "\\code"]
    #[doc = "vkDestroyBuffer(device, buffer, allocationCallbacks);"]
    #[doc = "vmaFreeMemory(allocator, allocation);"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = "It it safe to pass null as buffer and/or allocation."]
    pub fn vmaDestroyBuffer(allocator: VmaAllocator, buffer: Buffer, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " Function similar to vmaCreateBuffer()."]
    pub fn vmaCreateImage(
        allocator: VmaAllocator,
        pImageCreateInfo: *const ImageCreateInfo,
        pAllocationCreateInfo: *const VmaAllocationCreateInfo,
        pImage: *mut Image,
        pAllocation: *mut VmaAllocation,
        pAllocationInfo: *mut VmaAllocationInfo,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Destroys Vulkan image and frees allocated memory."]
    #[doc = ""]
    #[doc = "This is just a convenience function equivalent to:"]
    #[doc = ""]
    #[doc = "\\code"]
    #[doc = "vkDestroyImage(device, image, allocationCallbacks);"]
    #[doc = "vmaFreeMemory(allocator, allocation);"]
    #[doc = "\\endcode"]
    #[doc = ""]
    #[doc = "It it safe to pass null as image and/or allocation."]
    pub fn vmaDestroyImage(allocator: VmaAllocator, image: Image, allocation: VmaAllocation);
}
extern "C" {
    #[doc = " \\brief Creates new #VmaVirtualBlock object."]
    #[doc = ""]
    #[doc = "\\param pCreateInfo Parameters for creation."]
    #[doc = "\\param[out] pVirtualBlock Returned virtual block object or `VMA_NULL` if creation failed."]
    pub fn vmaCreateVirtualBlock(
        pCreateInfo: *const VmaVirtualBlockCreateInfo,
        pVirtualBlock: *mut VmaVirtualBlock,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Destroys #VmaVirtualBlock object."]
    #[doc = ""]
    #[doc = "Please note that you should consciously handle virtual allocations that could remain unfreed in the block."]
    #[doc = "You should either free them individually using vmaVirtualFree() or call vmaClearVirtualBlock()"]
    #[doc = "if you are sure this is what you want. If you do neither, an assert is called."]
    #[doc = ""]
    #[doc = "If you keep pointers to some additional metadata associated with your virtual allocations in their `pUserData`,"]
    #[doc = "don't forget to free them."]
    pub fn vmaDestroyVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    #[doc = " \\brief Returns true of the #VmaVirtualBlock is empty - contains 0 virtual allocations and has all its space available for new allocations."]
    pub fn vmaIsVirtualBlockEmpty(virtualBlock: VmaVirtualBlock) -> Bool32;
}
extern "C" {
    #[doc = " \\brief Returns information about a specific virtual allocation within a virtual block, like its size and `pUserData` pointer."]
    pub fn vmaGetVirtualAllocationInfo(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pVirtualAllocInfo: *mut VmaVirtualAllocationInfo,
    );
}
extern "C" {
    #[doc = " \\brief Allocates new virtual allocation inside given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "If the allocation fails due to not enough free space available, `VK_ERROR_OUT_OF_DEVICE_MEMORY` is returned"]
    #[doc = "(despite the function doesn't ever allocate actual GPU memory)."]
    #[doc = "`pAllocation` is then set to `VK_NULL_HANDLE` and `pOffset`, if not null, it set to `UINT64_MAX`."]
    #[doc = ""]
    #[doc = "\\param virtualBlock Virtual block"]
    #[doc = "\\param pCreateInfo Parameters for the allocation"]
    #[doc = "\\param[out] pAllocation Returned handle of the new allocation"]
    #[doc = "\\param[out] pOffset Returned offset of the new allocation. Optional, can be null."]
    pub fn vmaVirtualAllocate(
        virtualBlock: VmaVirtualBlock,
        pCreateInfo: *const VmaVirtualAllocationCreateInfo,
        pAllocation: *mut VmaVirtualAllocation,
        pOffset: *mut DeviceSize,
    ) -> Result;
}
extern "C" {
    #[doc = " \\brief Frees virtual allocation inside given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "It is correct to call this function with `allocation == VK_NULL_HANDLE` - it does nothing."]
    pub fn vmaVirtualFree(virtualBlock: VmaVirtualBlock, allocation: VmaVirtualAllocation);
}
extern "C" {
    #[doc = " \\brief Frees all virtual allocations inside given #VmaVirtualBlock."]
    #[doc = ""]
    #[doc = "You must either call this function or free each virtual allocation individually with vmaVirtualFree()"]
    #[doc = "before destroying a virtual block. Otherwise, an assert is called."]
    #[doc = ""]
    #[doc = "If you keep pointer to some additional metadata associated with your virtual allocation in its `pUserData`,"]
    #[doc = "don't forget to free it as well."]
    pub fn vmaClearVirtualBlock(virtualBlock: VmaVirtualBlock);
}
extern "C" {
    #[doc = " \\brief Changes custom pointer associated with given virtual allocation."]
    pub fn vmaSetVirtualAllocationUserData(
        virtualBlock: VmaVirtualBlock,
        allocation: VmaVirtualAllocation,
        pUserData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Calculates and returns statistics about virtual allocations and memory usage in given #VmaVirtualBlock."]
    pub fn vmaCalculateVirtualBlockStats(
        virtualBlock: VmaVirtualBlock,
        pStatInfo: *mut VmaStatInfo,
    );
}
extern "C" {
    #[doc = " \\brief Builds and returns a null-terminated string in JSON format with information about given #VmaVirtualBlock."]
    #[doc = "\\param virtualBlock Virtual block."]
    #[doc = "\\param[out] ppStatsString Returned string."]
    #[doc = "\\param detailedMap Pass `VK_FALSE` to only obtain statistics as returned by vmaCalculateVirtualBlockStats(). Pass `VK_TRUE` to also obtain full list of allocations and free spaces."]
    #[doc = ""]
    #[doc = "Returned string must be freed using vmaFreeVirtualBlockStatsString()."]
    pub fn vmaBuildVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: Bool32,
    );
}
extern "C" {
    #[doc = " Frees a string returned by vmaBuildVirtualBlockStatsString()."]
    pub fn vmaFreeVirtualBlockStatsString(
        virtualBlock: VmaVirtualBlock,
        pStatsString: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Builds and returns statistics as a null-terminated string in JSON format."]
    #[doc = "\\param allocator"]
    #[doc = "\\param[out] ppStatsString Must be freed using vmaFreeStatsString() function."]
    #[doc = "\\param detailedMap"]
    pub fn vmaBuildStatsString(
        allocator: VmaAllocator,
        ppStatsString: *mut *mut ::std::os::raw::c_char,
        detailedMap: Bool32,
    );
}
extern "C" {
    pub fn vmaFreeStatsString(allocator: VmaAllocator, pStatsString: *mut ::std::os::raw::c_char);
}
